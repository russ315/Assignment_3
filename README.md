# Assignment 3: Optimization of a City Transportation Network (MST)

This repository contains a Java implementation of **Prim's** and **Kruskal's** algorithms to find the Minimum Spanning Tree (MST) for a set of graphs, as described in the assignment. The program reads graph data from an input JSON file, calculates the MST using both algorithms, and outputs the results along with performance metrics to an output JSON file.

## Analytical Report

This report analyzes the application and performance of Prim's and Kruskal's algorithms on the provided graph data.

### 1. Summary of Input Data and Algorithm Results

The objective was to find the MST for two graphs. Both algorithms were run, and their performance metrics (execution time and a custom operation count) were recorded. Both algorithms successfully found an MST with the identical, correct total cost for both graphs.

**Operation Count Definition:**
* **Kruskal's:** Operations include each edge comparison during sorting, each loop iteration, and each `find()` and `union()` call.
* **Prim's:** Operations include `pq.add()`, `pq.poll()`, `visited.add()`, `visited.contains()`, and internal comparisons within the `PriorityQueue`.

**Results Summary:**

| Graph ID | Input Vertices | Input Edges | Algorithm | Total Cost | Operations Count | Execution Time (ms) |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **1** | 5 | 7 | **Prim's** | 16 | 51 | 2.148 |
| **1** | 5 | 7 | **Kruskal's** | 16 | 42 | 1.025 |
| **2** | 4 | 5 | **Prim's** | 6 | 31 | 0.174 |
| **2** | 4 | 5 | **Kruskal's** | 6 | 27 | 0.211 |

*(Note: Performance metrics are based on a single run and may vary slightly based on the execution environment.)*

---

### 2. Performance Comparison

The performance of the two algorithms was analyzed based on the generated metrics.

* **Graph 1 (V=5, E=7):** **Kruskal's algorithm** was the clear winner. It was more than twice as fast (1.025 ms vs. 2.148 ms) and performed fewer operations (42 vs. 51). This suggests its overhead (sorting 7 edges, DSU operations) was lower than Prim's (managing the PriorityQueue and adjacency list).

* **Graph 2 (V=4, E=5):** The results were more nuanced. **Kruskal's algorithm** performed fewer operations (27 vs. 31), but **Prim's algorithm** had a slightly faster execution time (0.174 ms vs. 0.211 ms).

**Note on Metrics:** The execution times for both tests are extremely small (all under 2.2 milliseconds). At this scale, results can be heavily skewed by system factors like JIT compilation. The **operations\_count** is a more stable metric, and it consistently favored **Kruskal's algorithm** for both sparse graphs.

---

### 3. Conclusions and Algorithm Preference

The choice between algorithms depends on graph density and implementation.

* **Kruskal's Algorithm:** Its runtime is dominated by sorting all edges, giving a complexity of $O(E \log E)$ or $O(E \log V)$. Our tests, which used small, **sparse graphs** (where $E$ is close to $V$), showed Kruskal's to be highly efficient, requiring fewer defined operations in all cases.

* **Prim's Algorithm:** Its runtime, using a priority queue, is $O(E \log V)$. This algorithm truly shines in **dense graphs** (where $E$ approaches $V^2$). In such cases, Prim's $O(V^2)$ (with a Fibonacci heap) or $O(E \log V)$ (with a binary heap) is generally faster than Kruskal's $O(E \log E)$.

**Conclusion:**

For the stated problem of optimizing a "city transportation network," graphs are almost always **sparse**.

Based on our test results, which align with this theoretical understanding, **Kruskal's algorithm is the preferable choice for this specific assignment**. It demonstrated superior (or at worst, comparable) performance on the sparse test graphs and is conceptually straightforward for this problem type.

---

### 4. References
No external sources were used. All analysis is based on the provided assignment materials and the generated experimental data.

## How to Run the Code

### Dependencies

This project requires the **Google Gson** library for JSON parsing and serialization.
* **Maven:**
    ```xml
    <dependency>
      <groupId>com.google.code.gson</groupId>
      <artifactId>gson</artifactId>
      <version>2.10.1</version>
    </dependency>
    ```
* **Gradle:**
    ```groovy
    implementation 'com.google.code.gson:gson:2.10.1'
    ```

### Files
* `RunAssignment.java`: The main entry point of the application.
* `MSTAlgorithms.java`: Contains the implementations of Kruskal's and Prim's algorithms, along with helper classes.
* `POJO.java`: Contains the Plain Old Java Objects (POJOs) for mapping to the JSON structures.
* `ass_3_input.json`: The input file with graph data.
* `ass_3_output.json`: The output file generated by the program.

### Execution

1.  Place `ass_3_input.json` in the root directory of the project.
2.  Compile and run the `RunAssignment.java` file.
3.  The program will read the input file, execute both algorithms, and generate (or overwrite) `ass_3_output.json` in the same directory with the results.

### Generated `ass_3_output.json`

```json
{
  "results": [
    {
      "graph_id": 1,
      "input_stats": {
        "vertices": 5,
        "edges": 7
      },
      "prim": {
        "mst_edges": [
          {"from": "B", "to": "C", "weight": 2},
          {"from": "A", "to": "C", "weight": 3},
          {"from": "B", "to": "D", "weight": 5},
          {"from": "D", "to": "E", "weight": 6}
        ],
        "total_cost": 16,
        "operations_count": 51,
        "execution_time_ms": 2.148375
      },
      "kruskal": {
        "mst_edges": [
          {"from": "B", "to": "C", "weight": 2},
          {"from": "A", "to": "C", "weight": 3},
          {"from": "B", "to": "D", "weight": 5},
          {"from": "D", "to": "E", "weight": 6}
        ],
        "total_cost": 16,
        "operations_count": 42,
        "execution_time_ms": 1.024542
      }
    },
    {
      "graph_id": 2,
      "input_stats": {
        "vertices": 4,
        "edges": 5
      },
      "prim": {
        "mst_edges": [
          {"from": "A", "to": "B", "weight": 1},
          {"from": "B", "to": "C", "weight": 2},
          {"from": "C", "to": "D", "weight": 3}
        ],
        "total_cost": 6,
        "operations_count": 31,
        "execution_time_ms": 0.174208
      },
      "kruskal": {
        "mst_edges": [
          {"from": "A", "to": "B", "weight": 1},
          {"from": "B",_ "to": "C", "weight": 2},
          {"from": "C", "to": "D", "weight": 3}
        ],
        "total_cost": 6,
        "operations_count": 27,
        "execution_time_ms": 0.210792
      }
    }
  ]
}